# -*- coding: utf-8 -*-
"""Copia de Proyecto - Programaci√≥n 2.ipynby
**Natalia Prieto estuvo aqu√≠ <3 ‚ãÜ‡≠®‡≠ß‚ãÜ presente presidente
**Mar√≠a Alejandra Pel√°ez ñ¶π¬∞‚Äß‚òÖ‚ãÜ
Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BBT24DBss449Pp0ljdgyfG57wm07xRq1

**PROYECTO HERRAMIENTAS DE PROGRAMACI√ìN II**

DATOS DE LA GEIH DEL PRIMER SEMESTRE DE 2024
"""

import pandas as pd
import numpy as np
import statsmodels.api as sm
import matplotlib.pyplot as plt
from transformers import TimesFmModelForPrediction
import torch

from google.colab import drive
drive.mount('/content/drive')

meses = ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre"]

lista_dfs = {}

for mes in meses:
  df_car_mes = pd.read_stata(f"/content/drive/MyDrive/Colab Notebooks/Programaci√≥n II/Proyecto /Datos/{mes}/Caracter√≠sticas Generales.DTA")
  df_ocp_mes = pd.read_stata(f"/content/drive/MyDrive/Colab Notebooks/Programaci√≥n II/Proyecto /Datos/{mes}/Ocupados.DTA")
  df_mes = pd.merge(df_car_mes, df_ocp_mes, how='right', on= ["DIRECTORIO", "SECUENCIA_P"])
  lista_dfs[mes] = df_mes
  print(f"Descarga mes de {mes} lista")

df = pd.concat(lista_dfs.values(), ignore_index= True)

df

df = df.rename(columns={"P3271" : "sexo",
                "P6040" : "edad",
                "P6050" : "parentesco jefe h",
                "P6090" : "seg social salud",
                "P3042" : "nivel educativo",
                "P3042S1" : "a√±os estudio",
                "P6426" : "tiempo en la empresa",
                "P6500" : "ing bruto",
                "P6800" : "hr trabajo sem",
                "P6790" : "# meses trabajados (ult. a√±o)",
                "P6920" : "cotiza a pension",
                "P6640S1" : "hr extra rem (ult. sem)"})

var_rel = ["sexo","edad","parentesco jefe h","seg social salud", "nivel educativo","a√±os estudio",
  "tiempo en la empresa","ing bruto","hr trabajo sem","# meses trabajados (ult. a√±o)",
  "cotiza a pension","hr extra rem (ult. sem)", "MES_x", "INGLABO"]

df["sexo"] = df["sexo"].replace(2, "Mujer")
df["sexo"] = df["sexo"].replace(1, "Hombre")

for i in df.columns.to_list():
  df[i] = df[i].apply(lambda x : np.nan if x=="99" or x== "98" else x)

df = df.dropna(axis=0, how='any', subset=var_rel)

df = df.fillna(0)

#Prueba de eliminaci√≥n de valores Nan
conteo_nan = df['ing bruto'].isnull().sum()
print(f"N√∫mero de NaN en la columna: {conteo_nan}")

"""* **Regresiones**"""

# Efecto del g√©nero sobre horas de trabajo semanal

# Controles: "edad", "a√±os estudio", "cotiza a pension"
# Variable de interes: "sexo",
# Variable dependient: horas de trabajo semanal

y = "hr trabajo sem"

vars_cat = ["sexo", "cotiza a pension"]

df_temp = df[vars_cat].copy()
df_temp = pd.get_dummies(df_temp,columns= vars_cat, drop_first=True)

x_cat = df_temp.columns.to_list()

for column in x_cat:
  df[column] = df_temp[column]

X = ["edad", "a√±os estudio"] + x_cat
df[X] = df[X].astype(float).fillna(0)

reg1 = sm.OLS(df["hr trabajo sem"],df[X])

reg1.fit().summary()

"""* **Series de tiempo**

1. Salario Mujeres en el tiempo
2. Salario Hombres en el tiempo
3. Diferencia de salarios en el tiempo

Video: https://www.youtube.com/watch?v=OGxPJfL5lJU

"""

df['Mes_index'] = df['MES_x'].tolist()
df = df.set_index('Mes_index')

df

# Comportamiento General de los Ingresos

df_inglabo_total = df.groupby('MES_x')['INGLABO'].mean()

plt.figure(figsize=(10, 6))
plt.plot(df_inglabo_total, marker = 'o')
plt.title('Promedio de Ingresos Laborales - 1er Semestre 2024')
plt.xlabel('Mes')
plt.ylabel('Ingreso Laboral/1000')
plt.grid(True, linestyle='--', alpha=0.7)
plt.show()

# DF de ingresos por g√©nero

df_inglabo_gen0 = df.groupby(['MES_x', 'sexo'])['INGLABO'].mean() #Agrupar por sexo
df_inglabo_gen = df_inglabo_gen0.unstack('sexo') # Separar los datos de hombre y mujeres en columnas
df_inglabo_gen['dif_ing'] = (df_inglabo_gen['Hombre']- df_inglabo_gen['Mujer'])*100/df_inglabo_gen['Hombre'] # Columna de diferencia de ingresos

df_inglabo_gen

# Comportamiento de ingresos Hombre y Mujeres

plt.figure(figsize=(10, 6))
df_inglabo_gen[['Hombre', 'Mujer']].plot(ax=plt.gca(), marker='o')
plt.title('Ingreso Laboral Promedio por G√©nero (1er Semestre)')
plt.xlabel('Mes')
plt.ylabel('Promedio de Ingreso Laboral ($)')
plt.grid(True, linestyle='--')
plt.legend(title='G√©nero')
plt.show()

# Diferencia porcentual de ingresos Hombre y Mujeres

plt.figure(figsize= (10 , 6))
df_inglabo_gen['dif_ing'].plot(marker = 'o')
plt.title('Diferencia promedio de ingresos hombre vs mujeres')
plt.grid (True, linestyle = "--" )
plt.axhline(y=0, color = "black", linestyle= '--')
nota = '* Se calcul√≥ de la siguiente manera: ((Ingreso laboral promedio de los hombres) - (Ingreso laboral promedio de las mujeres)/(Ingreso laboral promedio de los hombres)).'
plt.figtext(x=0.1, y= 0.001, s=nota , color= 'gray')
plt.show()

"""* Modelo

https://huggingface.co/docs/transformers/model_doc/timesfm

1. Utilizando los primeros 8 meses del a√±o
"""

df_inglabo_gen_PARCIAL = df_inglabo_gen.head(8)

df_inglabo_gen_PARCIAL

model = TimesFmModelForPrediction.from_pretrained(
    "google/timesfm-2.0-500m-pytorch",
    dtype=torch.bfloat16,
    attn_implementation="sdpa",
    device_map="auto")


frequency_input = [0, 1, 2]

forecast_input_tensor = [torch.tensor(df_inglabo_gen_PARCIAL['dif_ing'], dtype=torch.bfloat16).to(model.device)]
frequency_input_tensor = torch.tensor(frequency_input, dtype=torch.long).to(model.device)

with torch.no_grad():
    outputs = model(past_values=forecast_input_tensor, freq=frequency_input_tensor, return_dict=True)
    point_forecast_conv = outputs.mean_predictions.float().cpu().numpy()
    quantile_forecast_conv = outputs.full_predictions.float().cpu().numpy()

forecast_PARCIAL = point_forecast_conv.T
df_forecast_PARCIAL = pd.DataFrame(data=forecast_PARCIAL)
df_forecast_PARCIAL['Index'] = np.arange(9, 137).tolist()
df_forecast_PARCIAL = df_forecast_PARCIAL.set_index('Index')

df_predict_PARCIAL = pd.concat([df_inglabo_gen_PARCIAL , df_forecast_PARCIAL[0:4]])
df_predict_PARCIAL = df_predict_PARCIAL.rename(columns = {0 : 'Predicci√≥n', 'dif_ing' : 'Diferencia porcentual de ingresos'})
df_predict_PARCIAL

plt.figure(figsize=(10, 6))
df_predict_PARCIAL[['Diferencia porcentual de ingresos', 'Predicci√≥n']].plot(ax=plt.gca(), marker='o')
plt.title('Diferencia promedio de ingresos hombre vs mujeres con predicciones')
plt.xlabel('Mes')
plt.ylabel('Diferencia porcentual')
plt.axhline(0, linestyle = '--',color ='black')
plt.grid(True, linestyle='--')
plt.legend(title='Series')
plt.show()

"""2. Utilizando el a√±o completo"""

model = TimesFmModelForPrediction.from_pretrained(
    "google/timesfm-2.0-500m-pytorch",
    dtype=torch.bfloat16,
    attn_implementation="sdpa",
    device_map="auto")


frequency_input = [0, 1, 2]

forecast_input_tensor = [torch.tensor(df_inglabo_gen['dif_ing'], dtype=torch.bfloat16).to(model.device)]
frequency_input_tensor = torch.tensor(frequency_input, dtype=torch.long).to(model.device)

with torch.no_grad():
    outputs = model(past_values=forecast_input_tensor, freq=frequency_input_tensor, return_dict=True)
    point_forecast_conv = outputs.mean_predictions.float().cpu().numpy()
    quantile_forecast_conv = outputs.full_predictions.float().cpu().numpy()

forecast = point_forecast_conv.T
df_forecast = pd.DataFrame(data=forecast)

forecast = point_forecast_conv.T
df_forecast = pd.DataFrame(data=forecast)
df_forecast['Index'] = np.arange(0, 128).tolist()
df_forecast = df_forecast.set_index('Index')

df_predict = pd.concat([df_inglabo_gen , df_forecast[1:13]])
df_predict = df_predict.rename(columns = {0 : 'Predicci√≥n a√±o 2025', 'dif_ing' : 'Diferencia porcentual de ingresos 2024'})

df_predict

plt.figure(figsize=(10, 6))
df_predict[['Diferencia porcentual de ingresos 2024', 'Predicci√≥n a√±o 2025']].plot(ax=plt.gca(), marker='o')
plt.title('Diferencia promedio de ingresos hombre vs mujeres con predicciones')
plt.xlabel('Mes')
plt.ylabel('Diferencia porcentual')
plt.axhline(0, linestyle = '--',color ='black')
plt.grid(True, linestyle='--')
plt.legend(title='Series')
plt.show()

